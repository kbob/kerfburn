#!/usr/bin/python

loggage = []
def log(msg):
    loggage.append(str(msg))

from abc import ABCMeta, abstractmethod, abstractproperty
from collections import namedtuple, OrderedDict
import copy
import curses
from curses.ascii import ESC
import functools
import math
import optparse
import os
import re
import select
import subprocess
import sys
import time


# Observer and Observable


class Observer(object):

    __metaclass__ = ABCMeta

    def __init__(self):
        self._observeds = []
        self._observations = dict()

    # Subclass interface

    def observe(self, observable):
        observable.add_observer(self)
        self._observeds = []
        self._observations.setdefault(observable, None)

    @abstractmethod
    def make_observation(self, observed):
        pass

    @abstractmethod
    def observe_change(self, observed):
        """subclasses override to process changes."""

    def last_observation(self, observed):
        return self._observations[observed]

    # Observed object interface

    def check_observed(self, observed):
        state = self.make_observation(observed)
        if self._observations[observed] != state:
            self._observations[observed] = copy.copy(state)
            self.observe_change(observed)
        

class Observable(object):

    def __init__(self):
        super(Observable, self).__init__()
        self._observers = set()

    def add_observer(self, observer):
        self._observers.add(observer)

    def notify_observers(self):
        for observer in self._observers:
            observer.check_observed(self)


# The basic design is Model-View-Controller.
#
# The Model is a passive object, the singleton member of class Model.
# It stores all the information that the Controller retrieves about
# the laser cutter's current state.
#
# The View either displays the model's information.  By default, it
# displays on a terminal in full screen mode.  It can alternately
# output a one-time snapshot as text.
#
# The Controller opens a thruport connection to the laser cutter,
# enables frequent reporting, and uses the resulting reports to update
# the model and, indirectly, the view.


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
# MODEL
#


# A Fault Descriptor describes a fault.  (duh...)

class FaultDesc(namedtuple('FaultDesc', 'id name')):
    pass


# Describe all faults.

all_faults = OrderedDict((f[0], FaultDesc(*f)) for f in (
    ('ES', 'Emergency Stop'),
    ('LO', 'Lid Open'),
    ('LC', 'Lid Closed'),
    ('WF', 'Water Flow'),
    ('WT', 'Water Temperature'),
    ('LS', 'Limit Switch Stuck'),
    ('SF', 'Serial Frame Error'),
    ('SO', 'Serial Overrun'),
    ('SP', 'Serial Parity Error'),
    ('SL', 'S-code Lexical Error'),
    ('SS', 'S-code Syntax Error'),
    ('SU', 'Software Underflow'),
    ('SI', 'Software Missed Interrupt'),
    ))


# The laser cutter has variables, and the veriables are of three types:
# signed integer, unsigned integer, and enumeration.  These classes
# help with the semantics of those types.

class Unsigned:

    @classmethod
    def default_value(cls):
        return 0

    @classmethod
    def format(cls, value, verbose=False):
        return str(value)

class Signed:

    @classmethod
    def default_value(cls):
        return 0

    @classmethod
    def format(cls, value, verbose=False):
        return '%+d' % value

class Enum(dict):

    def __init__(self, contents, default):
        super(Enum, self).__init__(contents)
        self.default = default

    def default_value(self):
        return self.default

    def format(self, value, verbose=False):
        v = self[value]
        if not verbose:
            v = {
                'Complete': 'Comp',
                'Continuous': 'Cont',
                'Distance': 'Dist',
                'Main Laser': 'Main',
                'Startup': 'Start',
                'Visible Laser': 'Vis',
                'Warning': 'Warn',
                }.get(v, v)
        return v

enum_ny    = Enum({'n': 'No', 'y': 'Yes'}, default='n')
enum_yn    = Enum({'n': 'No', 'y': 'Yes'}, default='y')
enum_ncswa = Enum({'n': 'None',
                   'c': 'Complete',
                   's': 'Startup',
                   'w': 'Warning',
                   'a': 'Alert'},
                  default='n')
enum_nmv   = Enum({'n': 'None',
                   'm': 'Main Laser',
                   'v': 'Visible Laser'},
                default='n')
enum_octd  = Enum({'o': 'Off',
                   'c': 'Continuous',
                   't': 'Timed',
                   'd': 'Distance'},
                  default='o')


# A Variable Descriptor describes a variable -- not its current value,
# but what it is: name, type, description.

class VarDesc(namedtuple('VarDesc', 'id type short_name full_name')):

    def default_value(self):
        return self.type.default_value()

    def format(self, value, verbose=False):
        return self.type.format(value, verbose)

    @property
    def is_report(self):
        i = self.id
        return i.startswith('r') and i != 'ri'

# All variables described.

all_vars = {v[0]: VarDesc(*v) for v in (
    ('ia', enum_ncswa, 'Illum. Anim.',    'Illumination Animation'),
    ('il', Unsigned,   'Illum. Level',    'Illumination Level'),
    ('lp', Unsigned,   'Laser Power',     'Laser Power'),
    ('ls', enum_nmv,   'Laser Select',    'Laser Select'),
    ('mt', Unsigned,   'Move Time',       'Move Time'),
    ('oc', enum_ny,    "O'ride Lid Shut", 'Override Lid Closed'),
    ('oo', enum_ny,    "O'ride Lid Open", 'Override Lid Open'),
    ('pd', Unsigned,   'Pulse Distance',  'Pulse Distance'),
    ('pi', Unsigned,   'Pulse Interval',  'Pulse Interval'),
    ('pm', enum_octd,  'Pulse Mode',      'Pulse Mode'),
    ('pw', Unsigned,   'Pulse Width',     'Pulse Width'),
    ('re', enum_yn,    'Report E-Stop',   'Report Emergency Stop Status'),
    ('rf', enum_yn,    'Report Faults',   'Report Fault Status'),
    ('ri', Unsigned,   'Rep. Interval',   'Reporting Interval (msec)'),
    ('rl', enum_ny,    'Report Limits',   'Report Limit Switch Status'),
    ('rm', enum_ny,    'Report Motors',   'Report Motor Status'),
    ('rp', enum_ny,    'Report Power',    'Report Power Status'),
    ('rq', enum_ny,    'Report Queues',   'Report Queue Status'),
    ('rr', enum_ny,    'Report RAM Use',  'Report RAM Status'),
    ('rs', enum_ny,    'Report Serial',   'Report Serial Status'),
    ('rv', enum_ny,    'Report Vars',     'Report Variables'),
    ('rw', enum_ny,    'Report Water',    'Report Water Status'),
    ('xd', Signed,     'X Distance',      'X Distance'),
    ('yd', Signed,     'Y Distance',      'Y Distance'),
    ('zd', Signed,     'Z Distance',      'Z Distance'),
    )}


model_status = Observable()
model_clock = Observable()
model_updates = Observable()


class Model(object):

    def __init__(self):
        super(Model, self).__init__()
        self._status = None
        self.version_string = '--'
        self.vars = {n: desc.default_value()
                     for (n, desc) in all_vars.iteritems()}
        self.faults = {f: False for f in all_faults}
        self.enabled = {}
        self.state = {}
        self.clock = None
        self.seq = 0

    def __str__(self):
        s = 'Model(\n'
        s += '      status:  %r\n' % self.status
        s += '      vars:    %r\n' % self.vars
        s += '      faults:  %r\n' % self.faults
        s += '      enabled: %r\n' % self.enabled
        s += '      state:   %r\n' % self.state
        return s
       
    def overall_status(self):
        if self.status:
            return self.status
        ss = self.state
        for q in ('xqueue', 'yqueue', 'zqueue', 'pqueue'):
            qv = ss.get(q)
            if qv is None:
                return '--'
            if qv != '0':
                return 'Running'
        return 'Idle'

    def laser_status(self):
        if self.status:
            return ''
        if self.faults['ES']:
            return '!Emergency Stop!'
        ls = self.vars['ls']
        s = all_vars['ls'].format(ls, verbose=True)
        if ls == 'n':
            return s
        pm = self.vars['pm']
        pm_str = all_vars['pm'].format(pm, verbose=True)
        if pm == 'o':
            pm_str = '!' + pm_str + '!'
        s = 'Pulse Mode: ' + pm_str
        
        if ls == 'm':
            if self.faults['LO'] and self.vars['oo'] == 'n':
                s = '!lid open!'
            elif self.enabled['high_voltage']:
                lp = self.vars['lp']
                if not lp:
                    s = '!power level zero!'
            else:
                s = '!high voltage disabled!'
            if not self.enabled['air']:
                s = '!air assist off!, ' + s
            if not self.enabled['water']:
                s = '!water off!, ' + s
            s = 'Main Laser, ' + s
        if ls == 'v':
            if self.faults['LC']:
                s = '!lid closed!'
            elif not self.enabled['low_voltage']:
                s = '!low voltage disabled!'
            elif self.state['low_voltage_ready'] == 'n':
                s = '!low voltage not ready!'
            s = 'Visible Laser, ' + s
        return s

    def motor_status(self):

        def format_dir(dir):
            if dir == '+':
                return 'pos'
            elif dir == '-':
                return 'neg'
            else:
                return ''

        if self.status:
            return ''
        ok = True
        s = ''
        if self.faults['ES']:
            s += ', !Emergency Stop!'
            ok = False
        xe = self.enabled.get('x_motor')
        ye = self.enabled.get('y_motor')
        ze = self.enabled.get('z_motor')
        if xe is None or ye is None or ze is None:
            pass
        elif not xe and not ye and not ze:
            # s += ', !all disabled!'
            ok = False
        elif not self.enabled.get('low_voltage', True):
            s += ', !low voltage disabled!'
            ok = False
        elif not self.state.get('low_voltage_ready', True):
            s += ', !low voltage not ready!'
            ok = False
        if ok:
            if xe:
                xd = format_dir(self.state['x_dir'])
                s += ', X ' + xd
            else:
                s += ', X disabled'
            if ye:
                yd = format_dir(self.state['y_dir'])
                s += ', Y ' + yd
            else:
                s += ', Y disabled'
            if ze:
                zd = format_dir(self.state['z_dir'])
                s += ', Z ' + zd
            else:
                s += ', Z disabled'

        if ok:
            s = 'Enabled' + s
        else:
            s = 'Disabled' + s
        return s

    LimitsState = namedtuple('limits', 'xmin xmax ymin ymax zmin zmax')
    
    SerialState = namedtuple('serial',
                             'rx_lines rx_chars rx_error tx_chars tx_error')

    PowerState = namedtuple('power',
                            'low_voltage high_voltage water air')

    def limits(self):
        return self._subset_dict(self.LimitsState, self.state)

    def serial(self):
        return self._subset_dict(self.SerialState, self.state, default=' ')

    def power(self):
        return self._subset_dict(self.PowerState, self.enabled)

    def _subset_dict(self, cls, dict_, default=None):
        return cls(*(dict_.get(f, default) for f in cls._fields))

    # Status is a string property.  It is observable through model_status.

    def get_status(self):
        return self._status

    def set_status(self, value):
        self._status = value
        model_status.notify_observers()

    status = property(get_status, set_status)

model = Model()


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
#  VIEW
#

# This is a perfectly ordinary object oriented GUI.  There are two
# interpenetrating hierarchies.  The inheritance hierarchy is rooted
# at the superclass, Window, and various types of windows subclass
# Window.  The layout hierarchy is rooted at the Screen, and child
# windows cover rectangular subregions of their parents.
#
# Each Window has a curses window as a member, which it uses for
# drawing.
#

# Utilities.

# front end for curses.addstr().  The string is padded to the width s.
# Exclamation points (!)  are replaced with attribute changes.
# Odd-numbered excls switch to Dangerous Red, and even-numbered excls
# switch back to normal text.

def addnstr_attr(win, y, x, w, s):
    attrs = (curses.A_NORMAL, curses.color_pair(1) | curses.A_BOLD)
    ai = 0
    assert type(s) == str, 's=%r' % (s,)
    for substr in s.split('!'):
        substr = substr[:w]
        win.addstr(y, x, substr, attrs[ai])
        x += len(substr)
        w -= len(substr)
        ai = 1 - ai
    if w:
        win.addstr(y, x, ' ' * w, attrs[0])

# pad or truncate the string to the width.
def pad(w, s):
    s = str(s)[:w]
    s += ' ' * (w - len(s))
    return s

# left-pad or left-truncate the string to the width.
def lpad(w, s):
    s = str(s)[:w]
    s = ' ' * (w - len(s)) + s
    return s


# Points and Rects are used for window layout.
class Point(namedtuple('Point', 'y x')):

    def __add__(self, other):
        return Point(self.y + other[0], self.x + other[1])

    def __sub__(self, other):
        # Arrrgh!  I've been reading too much Smalltalk code.
        return Point(self.y - other[0], self.x - other[1])


class Rect(namedtuple('Rect', 'origin size')):

    @property
    def extent(self):
        return self.origin + self.size


class Window(object):

    """the abstract base class of the window class hierarchy."""

    __metaclass__ = ABCMeta

    def __init__(self, title=None, children=[], curses_window=None):
        super(Window, self).__init__()
        self.parent = None
        self.children = children
        self.cwin = curses_window or curses.newwin(0, 0)
        self.title = title
        for child in children:
            child.parent = self

    # Geometry

    @abstractproperty
    def best_size(self):
        """Return a point."""

    @property
    def stretches(self):
        """Does this window stretch in Y or X?"""
        return (False, False)

    def layout(self, rect):
        # Windows with children will want to override this method.
        # N.B., rect is in absolute screen coordinates.
        self.bounds = rect

    # Decoration

    # x_ticks and y_ticks are used by Row and Column to draw separators.
    x_ticks = y_ticks = {}

    def titles(self):
        return ((0, self.title),)
    

    # Contents

    @abstractmethod
    def draw_unchanging(self):
        """Draw elements that won't change unless the window resizes"""

    @abstractmethod
    def draw_changing(self):
        """Draw elements that may change at any time."""

    def refresh(self, full):
        if full:
            self.cwin.erase()
            self.draw_unchanging()
        self.draw_changing()
        self.cwin.noutrefresh()

    refresh_list = []

    def needs_refresh(self):
        type(self).refresh_list.append(self)

    def all_need_refresh(self):
        self.needs_refresh()
        for child in self.children:
            child.all_need_refresh()

    # Geometric Properties

    def get_size(self):
        w = self.cwin
        return Point(*w.getmaxyx())

    def set_size(self, value):
        if value != self.size:
            w = self.cwin
            w.resize(*value)

    size = property(get_size, set_size)

    # N.B., a window's origin and bounds.origin are in abosolute
    # screen coordinates.  Its offset is relative to its parent's
    # origin.

    def get_origin(self):
        w = self.cwin
        origin = Point(*w.getbegyx())
        return origin

    def set_origin(self, value):
        w = self.cwin
        if value != self.origin:
            w.mvwin(*value)

    origin = property(get_origin, set_origin)

    def get_bounds(self):
        return Rect(self.origin, self.size)

    def set_bounds(self, value):
        self.size = Point(min(self.size.y, value.size.y),
                          min(self.size.x, value.size.x))
        self.origin = value.origin
        self.size = value.size

    bounds = property(get_bounds, set_bounds)

    @property
    def offset(self):
        offset = self.origin
        if self.parent:
            offset -= self.parent.origin
        return offset


class Screen(Window):

    """A Window class that represents the whole screen."""

    def __init__(self, curses_screen, child):
        super(Screen, self).__init__(None, [child], curses_screen)
        self._prev_size = None

    # Geometry

    @property
    def best_size(self):
        return self.child.best_size

    def layout(self, rect):
        self.child.layout(rect)

    # Contents

    def draw_unchanging(self):
        pass

    def draw_changing(self):
        pass

    def refresh(self, full=False):
        size_changed = self._prev_size != self.size
        if size_changed:
            self.layout(self.bounds)
            self._prev_size = self.size
            self.cwin.erase()
            self.all_need_refresh()
        refreshees = self.refresh_list[:]
        self.refresh_list[:] = []
        for window in refreshees:
            window.refresh(size_changed)
        curses.doupdate()

    # Hierarchy

    @property
    def child(self):
        return self.children[0]


class Column(Window):

    """A window subclass that arranges its children in a column."""
    def __init__(self, children):
        title = children[0].title if children else None
        super(Column, self).__init__(title, children)

    # Geometry

    @property
    def best_size(self):
        cs = [child.best_size for child in self.children]
        h = sum((size.y for size in cs), 0) + len(self.children) - 1
        w = max(size.x for size in cs)
        return Point(h, w)

    @property
    def stretches(self):
        cs = [child.stretches for child in self.children]
        return (any(s[0] for s in cs), all(s[1] for s in cs))

    def layout(self, rect):
        super(Column, self).layout(rect)
        heights = [child.best_size.y for child in self.children]
        excess_height = rect.size.y - self.best_size.y
        if excess_height > 0:
            stretchers = [i
                          for i, child in enumerate(self.children)
                          if child.stretches[0]]
            if stretchers:
                # XXX distribute evenly
                heights[stretchers[0]] += excess_height
        y, x = rect.origin
        h, w = rect.size
        for child, cheight in zip(self.children, heights):
            csize = Point(cheight, w)
            crect = Rect(Point(y, x), csize)
            child.layout(crect)
            y += cheight + 1
        self.y_ticks = [sum(heights[:i]) + i - 1
                        for i in range(1, len(heights))]
        if self.children:
            self.x_ticks = self.children[0].x_ticks

    # Decoration

    def titles(self):
        return self.children[0].titles() if self.children else ()

    # Contents

    def draw_unchanging(self):
        from curses import ACS_HLINE, ACS_TTEE, ACS_BTEE, ACS_PLUS
        w = self.cwin
        for uchild, lchild in zip(self.children[:-1], self.children[1:]):
            y = lchild.offset.y - 1
            w.hline(y, 0, ACS_HLINE, self.size.x)
            for x in uchild.x_ticks:
                w.vline(y, x, ACS_BTEE, 1)
            for x in lchild.x_ticks:
                ch = ACS_TTEE
                if x in uchild.x_ticks:
                    ch = ACS_PLUS
                w.vline(y, x, ch, 1)
            for x, title in lchild.titles():
                w.addstr(y, x + 1, ' %s ' % title, curses.A_BOLD)

    def draw_changing(self):
        pass


class Row(Window):

    """A window subclass that arranges its children in a row."""

    def __init__(self, children):
        title = children[0].title if children else None
        super(Row, self).__init__(title, children)

    # Geometry

    @property
    def best_size(self):
        cs = [child.best_size for child in self.children]
        h = max(size.y for size in cs)
        w = sum((size.x for size in cs), 0) + len(self.children) - 1
        return Point(h, w)

    @property
    def stretches(self):
        cs = [child.stretches for child in self.children]
        return (all(s[0] for s in cs), any(s[1] for s in cs))

    def layout(self, rect):
        super(Row, self).layout(rect)
        widths = [child.best_size.x for child in self.children]
        excess_width = rect.size.x - self.best_size.x
        if excess_width > 0:
            stretchers = [i
                          for i, child in enumerate(self.children)
                          if child.stretches[1]]
            ns = len(stretchers)
            xw = excess_width
            for s in stretchers:
                dw = xw // ns
                widths[s] += dw
                xw -= dw
                ns -= 1

        y, x = rect.origin
        h, w = rect.size
        for child, cwidth in zip(self.children, widths):
            csize = Point(h, cwidth)
            crect = Rect(Point(y, x), csize)
            child.layout(crect)
            x += cwidth + 1
        if self.children:
            self.y_ticks = self.children[0].y_ticks
        x_ticks = [child.offset.x - 1 for child in self.children[1:]]
        x_ticks += [xtik + child.offset.x
                    for child in self.children
                    for xtik in child.x_ticks]
        self.x_ticks = sorted(x_ticks)

    # Decoration

    def titles(self):
        return [(x + child.offset.x, label)
                for child in self.children
                for x, label in child.titles()]

    # Contents

    def draw_unchanging(self):
        from curses import ACS_VLINE, ACS_LTEE, ACS_RTEE, ACS_PLUS
        w = self.cwin
        for lchild, rchild in zip(self.children[:-1], self.children[1:]):
            x = rchild.origin.x - 1
            w.vline(0, x, ACS_VLINE, self.size.y)
            for y in lchild.y_ticks:
                w.hline(y, x, ACS_RTEE, 1)
            for y in rchild.y_ticks:
                ch = ACS_LTEE
                if y in lchild.y_ticks:
                    ch = ACS_PLUS
                w.hline(y, x, ch, 1)


    def draw_changing(self):
        pass


class StatusWindow(Window, Observer):

    """A window subclass that shows the laser cutter's overall status."""

    def __init__(self, title):
        super(StatusWindow, self).__init__(title)
        self.observe(model_updates)
        self.observe(model_status)
        self.observe(model_clock)

    # Geometry

    @property
    def best_size(self):
        return Point(6, 80)

    # Observation

    def make_observation(self, observed):
        if observed is model_updates:
            return model.seq
        if observed is model_status:
            return model.status
        if observed is model_clock:
            return model.clock
        assert False

    def observe_change(self, observed):
        self.needs_refresh()

    # Contents

    def draw_unchanging(self):
        w = self.cwin
        w.addstr(0, 2, self.title, curses.A_BOLD)
        w.addstr(2, 2, 'Status: ')
        w.addstr(3, 2, 'Laser:  ')
        w.addstr(4, 2, 'Motors: ')

    def draw_changing(self):
        w = self.cwin
        pw = self.size.x - 12
        now = self.last_observation(model_clock)
        time_str = time.strftime('%H:%M:%S', time.localtime(now))
        w.addstr(0, self.size.x - 9, time_str)
        addnstr_attr(w, 2, 10, pw, model.overall_status())
        addnstr_attr(w, 3, 10, pw, model.laser_status())
        addnstr_attr(w, 4, 10, pw, model.motor_status())


class ModelWindow(Window, Observer):

    def __init__(self, title):
        super(ModelWindow, self).__init__(title)
        self.observe(model_updates)
        self.observe(model_status)

    # Observation

    def make_observation(self, observed):
        if observed is model_updates:
            return self.observe_model()
        if observed is model_status:
            return model.status
        assert False

    def observe_change(self, observed):
        self.needs_refresh()

    @abstractmethod
    def observe_model(self):
        pass

    # Geometry

    def draw_changing(self):
        status = self.last_observation(model_status)
        state = self.last_observation(model_updates)
        if status or not state:
            self.blank_values()
        else:
            self.draw_values(state)

    @abstractmethod
    def blank_values(self):
        pass

    @abstractmethod
    def draw_values(self, state):
        pass


class PowerWindow(ModelWindow):

    def __init__(self, title):
        super(PowerWindow, self).__init__(title)
        self._labels = ('Motors', 'Laser', 'Water', 'Air')

    # Geometry

    @property
    def best_size(self):
        x = 2 + sum(len(lab) + 2 for lab in self._labels) - 1 + 2
        return Point(2, x)

    @property
    def stretches(self):
        return (False, True)

    def layout(self, rect):
        super(PowerWindow, self).layout(rect)
        lablen = sum(len(lab) for lab in self._labels)
        excess = self.size.x - lablen - 4
        cols = []
        x = 2
        n = len(self._labels)
        for lab in self._labels:
            d = excess // n
            cols.append(x + d // 2)
            x += len(lab) + d
            excess -= d
            n -= 1
        self._cols = cols

    # Observation

    def observe_model(self):
        return model.power()

    # Contents

    def draw_unchanging(self):
        w = self.cwin
        for x, label in zip(self._cols, self._labels):
            w.addstr(0, x, label)
            
    def blank_values(self):
        w = self.cwin
        for x in self._cols:
            w.addstr(1, x, '   ')
        
    def draw_values(self, power):
        w = self.cwin
        for value, x, label in zip(power, self._cols, self._labels):
            if value:
                w.addstr(1, x, 'ON', curses.color_pair(2) | curses.A_BOLD)
                w.addstr(1, x + 2, ' ')
            else:
                w.addstr(1, x, 'off')


class FaultWindow(ModelWindow):

    """A window subclass that shows the laser cutter's fault states."""

    def __init__(self, title):
        super(FaultWindow, self).__init__(title)
        self._name_w = max(len(desc.name) for desc in all_faults.values())
        self._faults = [(row, desc)
                        for row, desc in enumerate(all_faults.itervalues())]

    # Geometry

    @property
    def best_size(self):
        h = len(all_faults) + 1
        w = self._name_w + 11
        return Point(h, w)

    @property
    def stretches(self):
        return (True, True)

    # Observation

    def observe_model(self):
        return model.faults
             
    # Contents

    def draw_unchanging(self):
        pass

    def blank_values(self):
        w = self.cwin
        nw = self.size.x - 11
        for row, desc in self._faults:
            w.addstr(row, 2, ' ' * 5)
            w.addstr(row, 9, ' ' * nw)

    def draw_values(self, state):
        w = self.cwin
        nw = self.size.x - 11
        for row, desc in self._faults:
            if state:
                if state[desc.id]:
                    value = 'FAULT'
                    attr = curses.color_pair(1) | curses.A_BOLD
                else:
                    value = '   ok'
                    attr = curses.A_NORMAL
            else:
                value = '     '
                attr = curses.A_NORMAL
            name = desc.name
            w.addstr(row, 2, value, attr)
            w.addstr(row, 9, pad(nw, name), attr)


class VariablesWindow(ModelWindow):

    """A window subclass that shows the laser cutter's variables."""

    def __init__(self, title):

        def fmt_var(state, v):
            return all_vars[v].format(state[v])

        def fmt_reports(state):
            return ''.join([v[1], v[1].upper()][state[v] == 'y']
                           for v in reports)

        super(VariablesWindow, self).__init__(title)
        vars = sorted(all_vars.iteritems())
        reports = [v for v, d in vars if d.is_report]
        non_reports = [(v, d) for v, d in vars if not d.is_report]
        rlabel = 'Reports'
        self._labels = [d.short_name for v, d in non_reports] + [rlabel]
        self._vars = [(len(d.short_name),
                       functools.partial(fmt_var, v=v))
                      for v, d in non_reports] + [(len(rlabel), fmt_reports)]

    # Geometry

    @property
    def best_size(self):
        h = len(self._labels) + 1
        w = 2 + 20 + 1
        return Point(h, w)

    @property
    def stretches(self):
        return (True, False)

    # Observation

    def observe_model(self):
        return model.vars

    # Contents

    def draw_unchanging(self):
        w = self.cwin
        row = 0
        for label in self._labels:
            w.addstr(row, 2, label)
            row += 1

    def blank_values(self):
        w = self.cwin
        rx = self.size.x - 3
        for row, (lw, fmt) in enumerate(self._vars):
            w.addstr(row, 2 + lw, ' ' * (rx - lw))

    def draw_values(self, vars):
        w = self.cwin
        rx = self.size.x - 3
        for row, (lw, fmt) in enumerate(self._vars):
            value = fmt(vars)
            w.addstr(row, 2 + lw, lpad(rx - lw, value))


class LimitsWindow(ModelWindow):

    """A window subclass that shows the laser cutter's limit switches."""
    def __init__(self, title):
        super(LimitsWindow, self).__init__(title)

    # Geometry

    @property
    def best_size(self):
        return Point(4, 14)

    @property
    def stretches(self):
        return (True, False)

    # Observation

    def observe_model(self):
        return model.limits()

    # Contents

    def draw_unchanging(self):
        w = self.cwin
        w.addstr(0, 5, 'Min Max')
        w.addstr(1, 2, 'X')
        w.addstr(2, 2, 'Y')
        w.addstr(3, 2, 'Z')

    def blank_values(self):
        w = self.cwin
        for row in (1, 2, 3):
            for col in (6, 10):
                w.addstr(row, col, ' ')
        
    def draw_values(self, limits):
        w = self.cwin
        w.addstr(1, 6, limits.xmin or ' ')
        w.addstr(1, 10, limits.xmax or ' ')
        w.addstr(2, 6, limits.ymin or ' ')
        w.addstr(2, 10, limits.ymax or ' ')
        w.addstr(3, 6, limits.zmin or ' ')
        w.addstr(3, 10, limits.zmax or ' ')


class SerialWindow(ModelWindow):

    """A window subclass that shows the laser cutter's serial status."""

    def __init__(self, title):
        super(SerialWindow, self).__init__(title)

    # Geometry

    @property
    def best_size(self):
        return Point(9, 14)

    # Observation

    def observe_model(self):
        return model.serial()

    # Contents

    def draw_unchanging(self):
        w = self.cwin
        w.addstr(0, 2, 'RX')
        w.addstr(1, 7, 'lines')
        w.addstr(2, 7, 'chars')
        w.addstr(3, 7, 'error')

        w.addstr(5, 2, 'TX')
        w.addstr(6, 7, 'chars')
        w.addstr(7, 7, 'error')

    def blank_values(self):
        w = self.cwin
        for row in (1, 2, 3, 6, 7):
            w.addstr(row, 2, '    ')
        
    def draw_values(self, serial):
        w = self.cwin
        w.addstr(1, 2, lpad(4, serial.rx_lines))
        w.addstr(2, 2, lpad(4, serial.rx_chars))
        w.addstr(3, 2, lpad(4, serial.rx_error))

        w.addstr(6, 2, lpad(4, serial.tx_chars))
        w.addstr(7, 2, lpad(4, serial.rx_error))


def create_view(screen):

    """Create and initialize the (curses) view."""

    # set some global curses state
    curses.use_default_colors()
    curses.curs_set(0)
    curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_RED);
    curses.init_pair(2, curses.COLOR_GREEN, -1);

    # Create window hierarchy
    return Screen(screen,
                  Column([
                StatusWindow('Laser Cutter Monitor'),
                Row([
                        Column([
                                PowerWindow('Power'),
                                FaultWindow('Faults'),
                                ]),
                        Column([
                                LimitsWindow('Limits'),
                                SerialWindow('Serial'),
                                ]),
                        VariablesWindow('Variables'),
                        ])
                ])
                  )


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
#  CONTROLLER
#


def update_faults(line, vars):
    faults_set = set(line.split()[1:])
    m_f = model.faults
    for f in all_faults:
        b = f in faults_set
        m_f[f] = b
        

def update_ready(line, vars):
    send_enable_reporting()


def update_state(line, vars):
    m_e = model.enabled
    m_s = model.state
    for (name, value) in vars.iteritems():
        if name.endswith('_enabled'):
            short_name = name.replace('_enabled', '')
            value = {'n': False, 'y': True, 'd': False, 'e': True}[value]
            m_e[short_name] = value
        else:
            m_s[name] = value


def update_version(line, vars):
    model.version_string = 'Kerfburn ' + vars['version_string']
    model.status = None


def parse_var(exp, _match=re.compile(r'([a-z]{2})=(.*)').match):
    m = _match(exp)
    assert m, 'exp=%r' % exp
    return m.groups()


def update_vars(line, vars):
    m_v = model.vars
    exprs = line.split()[1:]
    for exp in exprs:
        name, value = parse_var(exp)
        try:
            value = int(value)
        except ValueError:
            pass
        m_v[name] = value


def update_water(line, vars):
    pass


def update_complete(line, vars):
    model.seq += 1
    model_updates.notify_observers()


# map the first lettter of each report line to a regular expression
# that parses the line and a function that updates the model.

updaters = {pat[0]: (re.compile(pat), func) for (pat, func) in (

        # --- = end of reports
        (r'---', update_complete),

        # E = Emergency Stop report
        (r'E o=(?P<lid_open>[yn]) '
            'b=(?P<stop_button>[yn]) '
            'l=(?P<main_laser_ok>[yn]) '
            'v=(?P<vis_laser_ok>[yn]) '
            'm=(?P<motors_ok>[yn])',
         update_state),

        # F - fault report
        (r'F', update_faults),

        # Kerfburn - version string
        (r'Kerfburn Back End, built +(?P<version_string>.*)', update_version),

        # L - limit switch report
        (r'L x=(?P<xmin>[_ny])(?P<xmax>[_ny]) '
            'y=(?P<ymin>[_ny])(?P<ymax>[_ny]) '
            'z=(?P<zmin>[_ny])(?P<zmax>[_ny])',
         update_state),

        # M - motor report
        (r'M x=(?P<x_motor_enabled>[de])(?P<x_dir>[-+]) '
            'y=(?P<y_motor_enabled>[de])(?P<y_dir>[-+]) '
            'z=(?P<z_motor_enabled>[de])(?P<z_dir>[-+])',
         update_state),

        # P - power report
        (r'P le=(?P<low_voltage_enabled>[ny]) '
            'lr=(?P<low_voltage_ready>[ny]) '
            'he=(?P<high_voltage_enabled>[ny]) '
            'ae=(?P<air_enabled>[ny]) '
            'we=(?P<water_enabled>[ny])',
         update_state),

        # Q - queues report
        (r'Q x=(?P<xqueue>\d+) '
            'y=(?P<yqueue>\d+) '
            'z=(?P<zqueue>\d+) '
            'p=(?P<pqueue>\d+)',
         update_state),

        # R - RAM report
        (r'R t=(?P<text_size>\d+) '
            'd=(?P<data_size>\d+) '
            'b=(?P<bss_size>\d+) '
            'f=(?P<free_size>\d+) '
            's=(?P<stack_size>\d+)',
         update_state),

        # S - serial report
        (r'S rx c=(?P<rx_chars>\d+) '
               'l=(?P<rx_lines>\d+) '
               'e=(?P<rx_error>(?:0x)?[\dA-Fa-f]+), '
            'tx c=(?P<tx_chars>\d+) '
               'e=(?P<tx_error>(?:0x)?[\dA-Fa-f]+)',
         update_state),

        # V - variables report
        (r'V', update_vars),

        # W - water report
        (r'W', update_water),

        )}
 

def update_model(line):
    key = line[:1]
    pf = updaters.get(key)
    if pf:
        pat, func = pf
        m = pat.match(line)
        if m:
            func(line, m.groupdict())
            return
    elif line:
        model.status = '!' + line


class Waitable(object):

    """abstract base class for things that select() can wait for."""

    __metaclass__ = ABCMeta

    @property
    def readfd(self):
        return None

    @property
    def writefd(self):
        return None

    @property
    def exceptfd(self):
        return None

    @property
    def timeout(self):
        return None

    @classmethod
    def select(cls, waitables):

        def collect(selector):
            return [fd
                    for fd in (selector(w) for w in waitables)
                    if fd is not None]

        readfds = collect(lambda w: w.readfd)
        writefds = collect(lambda w: w.writefd)
        exceptfds = collect(lambda w: w.exceptfd)
        # Damn it, I've been reading too much Lisp code.
        timeouts = collect(lambda w: (lambda t: ((t, w)
                                                 if t is not None
                                                 else None))(w.timeout))
        timeout = min(timeouts)[0] if timeouts else None

        try:
            r, w, x = select.select(readfds, writefds, exceptfds, timeout)
        except select.error:
            return

        for rfd in r:
            waitables[readfds.index(rfd)].do_read()
        for wfd in w:
            waitables[writefds.index(wfd)].do_write()
        for xfd in x:
            waitables[exceptfds.index(xfd)].do_except()
        if not any((r, w, x)):
            for (t, w) in timeouts:
                if t == timeout:
                   w.do_timeout()


class Clock(Waitable):

    """wait for the next seconds tick."""

    @property
    def timeout(self):
        return 1.0 - math.modf(time.time())[0]

    def do_timeout(self):
        now = int(time.time())
        if now != model.clock:
            model.clock = now
            model_clock.notify_observers()


class Receiver(Waitable):

    """accept input from "thruport receive"."""

    def __init__(self):
        super(Receiver, self).__init__()
        self.receive_proc = subprocess.Popen(['thruport', 'receive'],
                                        stdout=subprocess.PIPE,
                                        bufsize=0)
        self.rec_stream = self.receive_proc.stdout
        self.inbuf = ''

    def __del__(self):
        self.receive_proc.terminate()

    @property
    def readfd(self):
        return self.rec_stream

    def do_read(self):
        b = os.read(self.rec_stream.fileno(), 500)
        if b == '':
            exit()
        self.inbuf += b
        while '\n' in self.inbuf:
            line, self.inbuf = self.inbuf.split('\n', 1)
            line = line.rstrip('\r')
            if line == 'Ready':
                send_enable_reporting()
            else:
                update_model(line)


class TTY(Waitable):

    """accept TTY input."""

    @property
    def readfd(self):
        return sys.stdin

    def do_read(self):
        ch = os.read(sys.stdin.fileno(), 1)
        if ch.upper() == 'Q' or ch == chr(ESC):
            exit()


def send_enable_reporting():

    """Send the S-code command to enable full reporting."""

    send_proc = subprocess.Popen(['thruport', 'send'],
                                 stdin=subprocess.PIPE,
                                 stderr=open('/dev/null', 'w'),
                                 bufsize=0)
    sender = send_proc.stdin
    for v in all_vars:
        if v.startswith('r') and v != 'ri':
            sender.write('%s=%s\n' % (v, 'ny'[v not in ('rr', 'rw')]))
    sender.write('ri=500\n')
    sender.write('Er\n')
    sender.flush()
    sender.close()
    send_proc.wait()


def curses_main(stdscr):

    window = create_view(stdscr)
    waitables = [TTY(), Receiver(), Clock()]
    send_enable_reporting()

    while True:
        Waitable.select(waitables)
        window.refresh()


def logging_main():

    waitables = [Receiver()]
    send_enable_reporting()

    while model.seq == 0:
        Waitable.select(waitables)

    print model
    # init()

    # inbuf = ''
    # line_count = 0
    # while True:
    #     b = receiver.read(10)
    #     if b == '':
    #         break
    #     inbuf += b
    #     while '\n' in inbuf:
    #         line, inbuf = inbuf.split('\n', 1)
    #         line_count += 1
    #         update_model(line)
    #         print repr(line)[1:-1]
    #     if not inbuf and line_count >= 10:
    #         break


def main(argv):
    parser = optparse.OptionParser()
    parser.add_option('-l', '--log', action='store_true', help='logging mode')
    (options, args) = parser.parse_args(argv[1:])
    if args:
        parser.print_help()
        exit()
    if options.log:
        logging_main()
    else:
        curses.wrapper(curses_main)


if __name__ == '__main__':
    try:
        main(sys.argv)
    finally:
        for line in loggage:
            print line
